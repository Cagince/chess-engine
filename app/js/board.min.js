var GameBoard, GeneratePosKey, PIECEINDEX, PaeseFedn, ResetBoard;

PIECEINDEX = function(pce, pceNum) {
  return pce * 10 + pceNum;
};

GameBoard = {};

GameBoard.pieces = new Array(BOARD_SQUARE_NUMBER);

GameBoard.side = COLOURS.WHITE;

GameBoard.fiftyMove = 0;

GameBoard.playHistory = 0;

GameBoard.ply = 0;


/*
 * 0001 white king castling
 * 0010 white queen castling
 * 0100 black king castling
 * 1000 black queen castling
 * -----------------------------
 * 1101 = 13 <- white cannot castle queen side
 * Bitwise & to implement
 * .............................
 */

GameBoard.castlingPermission = 0;

GameBoard.enPasant = 0;

GameBoard.material = new Array(2);

GameBoard.pieceAmount = new Array(13);

GameBoard.pieceListArray = new Array(14 * 10);

GameBoard.positionKey = 0;

GameBoard.moveList = new Array(MAXDEPTH * MAXPOSITIONMOVES);

GameBoard.moveScores = new Array(MAXDEPTH * MAXPOSITIONMOVES);

GameBoard.moveListStart = new Array(MAXDEPTH);


/*
 * Generating Position keys for
 * later usage.
 * helps us getting aware of our game "input"
 * and add-remove pieces by xor'ing the final key
 */

GeneratePosKey = function() {
  var finalKey, j, piece, ref, sq;
  piece = PIECES.EMPTY;
  finalKey = 0;
  for (sq = j = 0, ref = BOARD_SQUARE_NUMBER; 0 <= ref ? j <= ref : j >= ref; sq = 0 <= ref ? ++j : --j) {
    piece = GameBoard.pieces[sq];
    if (piece !== PIECES.EMPTY && piece !== SQUARES.OFFBOARD) {
      finalKey ^= PieceKeys[(piece * 120) + sq];
    }
  }
  if (GameBoard.side === COLOURS.WHITE) {
    finalkey ^= SideKey;
  }
  if (GameBoard.enPasant !== SQUARES.NO_SQ) {
    finalKey ^= PieceKeys[GameBoard.enPasant];
  }
  finalKey ^= CastleKeys[GameBoard.castlingPermission];
  return finalKey;
};


/*
 * Reset the board
 * clear all to 0 , offset etc.
 */

ResetBoard = function() {
  var i, j;
  GameBoard.pieces.fill(SQUARES.OFFBOARD);
  Gameboard.pieceListArray.fill(PIECES.EMPTY);
  Gameboard.material.fill(0);
  Gameboard.pieceAmount.fill(0);
  for (i = j = 0; j <= 64; i = ++j) {
    Gameboard.pieces[SQ120(i)];
  }
  Gameboard.side = COLOURS.BOTH;
  Gameboard.enPasant = SQUARES.NO_SQ;
  Gameboard.fiftymove = 0;
  Gameboard.ply = 0;
  Gameboard.playHistory = 0;
  Gameboard.castlingPermission = 0;
  Gameboard.positionKey = 0;
  return Gameboard.moveListStart[Gameboard.ply] = 0;
};


/*
 * Method for parsing Forsythâ€“Edwards Notation String
 * more info on FEN: https://en.wikipedia.org/wiki/Forsyth%E2%80%93Edwards_Notation
 */

PaeseFedn = function(fen) {
  var count, fenCnt, file, i, j, k, piece, rank, ref, sq120;
  ResetBoard();
  fenCnt = 0;
  sq120 = 0;
  i = 0;
  count = 0;
  piece = 0;
  file = FILES.FILE_A;
  rank = RANKS.RANK_8;
  while ((rank >= RANKS.RANK_1) && fenCnt < fen.length) {
    count = 1;
    switch (fen[fenCnt]) {
      case 'p':
        piece = PIECES.bP;
        break;
      case 'r':
        piece = PIECES.bR;
        break;
      case 'n':
        piece = PIECES.bN;
        break;
      case 'b':
        piece = PIECES.bB;
        break;
      case 'k':
        piece = PIECES.bK;
        break;
      case 'q':
        piece = PIECES.bQ;
        break;
      case 'P':
        piece = PIECES.wP;
        break;
      case 'R':
        piece = PIECES.wR;
        break;
      case 'N':
        piece = PIECES.wN;
        break;
      case 'B':
        piece = PIECES.wB;
        break;
      case 'K':
        piece = PIECES.wK;
        break;
      case 'Q':
        piece = PIECES.wQ;
        break;
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
        piece = PIECES.EMPTY;
        count = fen[fenCnt].charCodeAt() - '0'.charCodeAt();
        break;
      case '/':
      case ' ':
        rank--;
        file = FILES.FILE_A;
        fenCnt++;
        continue;
      default:
        alert("not a valid FEN");
    }
    for (i = j = 0, ref = count; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
      sq120 = FR2SQ(file, rank);
      GameBoard.pieces[sq120] = piece;
      file++;
    }
    fenCnt++;
  }
  GameBoard.side = fen[fenCnt] === 'w' ? COLOURS.WHITE : COLOURS.BLACK;
  fenCnt += 2;
  for (i = k = 0; k <= 4; i = ++k) {
    if (fen[fenCnt] === ' ') {
      break;
    }
    switch (fen[fenCnt]) {
      case 'K':
        GameBoard.castlingPermission |= CASTLEBIT.WKCA;
        break;
      case 'Q':
        GameBoard.castlingPermission |= CASTLEBIT.WQCA;
        break;
      case 'k':
        GameBoard.castlingPermission |= CASTLEBIT.BKCA;
        break;
      case 'q':
        GameBoard.castlingPermission |= CASTLEBIT.BQCA;
        break;
      default:
        break;
    }
    fenCnt++;
  }
  fenCnt++;
  if (fen[fenCnt] !== '-') {
    file = fen[fenCnt].charCodeAt() - 'a'.charCodeAt();
    rank = fen[fenCnt + 1].charCodeAt() - '1'.charCodeAt();
    console.log("fen[fenCnt]: " + fen[fenCnt], " File: " + file + " Rank: " + rank);
    GameBoard.enPasant = FR2SQ(rank, file);
  }
  return Gameboard.posKey = GeneratePosKey();
};
