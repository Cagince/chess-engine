var GameBoard, GeneratePosKey, PIECEINDEX, ParseFen, PrintBoard, PrintPieceLists, ResetBoard, UpdateListMaterial;

PIECEINDEX = function(pce, pceNum) {
  return pce * 10 + pceNum;
};

GameBoard = {};

GameBoard.pieces = new Array(BOARD_SQUARE_NUMBER);

GameBoard.side = COLOURS.WHITE;

GameBoard.fiftyMove = 0;

GameBoard.playHistory = 0;

GameBoard.ply = 0;


/*
 * 0001 white king castling
 * 0010 white queen castling
 * 0100 black king castling
 * 1000 black queen castling
 * -----------------------------
 * 1101 = 13 <- white cannot castle queen side
 * Bitwise & to implement
 * .............................
 */

GameBoard.castlingPermission = 0;

GameBoard.enPasant = 0;

GameBoard.material = new Array(2);

GameBoard.pieceAmount = new Array(13);

GameBoard.pieceListArray = new Array(14 * 10);

GameBoard.positionKey = 0;

GameBoard.moveList = new Array(MAXDEPTH * MAXPOSITIONMOVES);

GameBoard.moveScores = new Array(MAXDEPTH * MAXPOSITIONMOVES);

GameBoard.moveListStart = new Array(MAXDEPTH);


/*
 * Print game board to console
 */

PrintBoard = function() {
  var file, j, k, l, line, piece, rank, ref, ref1, ref2, ref3, ref4, ref5, sq;
  console.log("printing board...");
  console.log("\nGame Board: \n");
  for (rank = j = ref = RANKS.RANK_8, ref1 = RANKS.RANK_1; ref <= ref1 ? j <= ref1 : j >= ref1; rank = ref <= ref1 ? ++j : --j) {
    line = RankChar[rank] + "|";
    for (file = k = ref2 = FILES.FILE_A, ref3 = FILES.FILE_H; ref2 <= ref3 ? k <= ref3 : k >= ref3; file = ref2 <= ref3 ? ++k : --k) {
      sq = FR2SQ(file, rank);
      piece = GameBoard.pieces[sq];
      line += " " + PceChar[piece] + " ";
    }
    console.log(line);
  }
  console.log("------------------------------ ");
  line = "  ";
  for (file = l = ref4 = FILES.FILE_A, ref5 = FILES.FILE_H; ref4 <= ref5 ? l <= ref5 : l >= ref5; file = ref4 <= ref5 ? ++l : --l) {
    line += " " + FileChar[file] + " ";
  }
  console.log(line);
  console.log("side: " + SideChar[GameBoard.side]);
  console.log("enPas: " + GameBoard.enPasant);
  line = "";
  if (GameBoard.castlingPermission && CASTLEBIT.WKCA) {
    line += "K";
  }
  if (GameBoard.castlingPermission && CASTLEBIT.WQCA) {
    line += "Q";
  }
  if (GameBoard.castlingPermission && CASTLEBIT.BKCA) {
    line += "k";
  }
  if (GameBoard.castlingPermission && CASTLEBIT.BQCA) {
    line += "q";
  }
  console.log("castle: " + line);
  return console.log("Key: " + GameBoard.posKey.toString(16));
};


/*
 * Generating Position keys for
 * later usage.
 * helps us getting aware of our game "input"
 * and add-remove pieces by xor'ing the final key
 */

GeneratePosKey = function() {
  var finalKey, j, piece, ref, sq;
  console.log("Generating Position Key");
  piece = PIECES.EMPTY;
  finalKey = 0;
  for (sq = j = 0, ref = BOARD_SQUARE_NUMBER; 0 <= ref ? j <= ref : j >= ref; sq = 0 <= ref ? ++j : --j) {
    piece = GameBoard.pieces[sq];
    if (piece !== PIECES.EMPTY && piece !== SQUARES.OFFBOARD) {
      finalKey ^= PieceKeys[(piece * 120) + sq];
    }
  }
  if (GameBoard.side === COLOURS.WHITE) {
    finalKey ^= SideKey;
  }
  if (GameBoard.enPasant !== SQUARES.NO_SQ) {
    finalKey ^= PieceKeys[GameBoard.enPasant];
  }
  finalKey ^= CastleKeys[GameBoard.castlingPermission];
  return finalKey;
};


/*
 * Print piece list
 */

PrintPieceLists = function() {
  var j, pceNum, piece, ref, ref1, results;
  console.log("Printing piece Lists...");
  results = [];
  for (piece = j = ref = PIECES.wP, ref1 = PIECES.bK; ref <= ref1 ? j <= ref1 : j >= ref1; piece = ref <= ref1 ? ++j : --j) {
    results.push((function() {
      var k, ref2, results1;
      results1 = [];
      for (pceNum = k = 0, ref2 = GameBoard.pieceAmount[piece] - 1; 0 <= ref2 ? k <= ref2 : k >= ref2; pceNum = 0 <= ref2 ? ++k : --k) {
        results1.push(console.log("piece : " + PceChar[piece] + " on " + PringSq(GameBoard.pieceListArray[PIECEINDEX(piece, pceNum)])));
      }
      return results1;
    })());
  }
  return results;
};


/*
 *
 */

UpdateListMaterial = function() {
  var colour, i, j, piece, sq;
  console.log("Updating List Material...");
  GameBoard.pieceListArray.fill(PIECES.EMPTY);
  GameBoard.material.fill(0);
  GameBoard.pieceAmount.fill(0);
  for (i = j = 0; j <= 63; i = ++j) {
    sq = SQ120(i);
    piece = GameBoard.pieces[sq];
    if (piece !== PIECES.EMPTY) {
      console.log("piece " + piece + " on " + sq);
      colour = PieceCol[piece];
      GameBoard.material[colour] += PieceVal[piece];
      GameBoard.pieceListArray[PIECEINDEX(piece, GameBoard.pieceAmount[piece])] = sq;
      GameBoard.pieceAmount[piece]++;
    }
  }
  return PrintPieceLists();
};


/*
 * Reset the board
 * clear all to 0 , offset etc.
 */

ResetBoard = function() {
  var i, j;
  console.log("reseting Board");
  GameBoard.pieces.fill(SQUARES.OFFBOARD);
  for (i = j = 0; j <= 64; i = ++j) {
    GameBoard.pieces[SQ120(i)];
  }
  GameBoard.side = COLOURS.BOTH;
  GameBoard.enPasant = SQUARES.NO_SQ;
  GameBoard.fiftymove = 0;
  GameBoard.ply = 0;
  GameBoard.playHistory = 0;
  GameBoard.castlingPermission = 0;
  GameBoard.positionKey = 0;
  return GameBoard.moveListStart[GameBoard.ply] = 0;
};


/*
 * Method for parsing Forsythâ€“Edwards Notation String
 * more info on FEN: https://en.wikipedia.org/wiki/Forsyth%E2%80%93Edwards_Notation
 */

ParseFen = function(fen) {
  var count, fenCnt, file, i, j, k, piece, rank, ref, sq120;
  console.log("parsing FEN...");
  ResetBoard();
  fenCnt = 0;
  sq120 = 0;
  i = 0;
  count = 0;
  piece = 0;
  file = FILES.FILE_A;
  rank = RANKS.RANK_8;
  while ((rank >= RANKS.RANK_1) && fenCnt < fen.length) {
    count = 1;
    switch (fen[fenCnt]) {
      case 'p':
        piece = PIECES.bP;
        break;
      case 'r':
        piece = PIECES.bR;
        break;
      case 'n':
        piece = PIECES.bN;
        break;
      case 'b':
        piece = PIECES.bB;
        break;
      case 'k':
        piece = PIECES.bK;
        break;
      case 'q':
        piece = PIECES.bQ;
        break;
      case 'P':
        piece = PIECES.wP;
        break;
      case 'R':
        piece = PIECES.wR;
        break;
      case 'N':
        piece = PIECES.wN;
        break;
      case 'B':
        piece = PIECES.wB;
        break;
      case 'K':
        piece = PIECES.wK;
        break;
      case 'Q':
        piece = PIECES.wQ;
        break;
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
        piece = PIECES.EMPTY;
        count = fen[fenCnt].charCodeAt() - '0'.charCodeAt();
        break;
      case '/':
      case ' ':
        rank--;
        file = FILES.FILE_A;
        fenCnt++;
        continue;
      default:
        alert("not a valid FEN");
    }
    for (i = j = 1, ref = count; 1 <= ref ? j <= ref : j >= ref; i = 1 <= ref ? ++j : --j) {
      sq120 = FR2SQ(file, rank);
      GameBoard.pieces[sq120] = piece;
      file++;
    }
    fenCnt++;
  }
  GameBoard.side = fen[fenCnt] === 'w' ? COLOURS.WHITE : COLOURS.BLACK;
  fenCnt += 2;
  for (i = k = 0; k <= 4; i = ++k) {
    if (fen[fenCnt] === ' ') {
      break;
    }
    switch (fen[fenCnt]) {
      case 'K':
        GameBoard.castlingPermission |= CASTLEBIT.WKCA;
        break;
      case 'Q':
        GameBoard.castlingPermission |= CASTLEBIT.WQCA;
        break;
      case 'k':
        GameBoard.castlingPermission |= CASTLEBIT.BKCA;
        break;
      case 'q':
        GameBoard.castlingPermission |= CASTLEBIT.BQCA;
        break;
      default:
        break;
    }
    fenCnt++;
  }
  fenCnt++;
  if (fen[fenCnt] !== '-') {
    file = fen[fenCnt].charCodeAt() - 'a'.charCodeAt();
    rank = fen[fenCnt + 1].charCodeAt() - '1'.charCodeAt();
    console.log("fen[fenCnt]: " + fen[fenCnt], " File: " + file + " Rank: " + rank);
    GameBoard.enPasant = FR2SQ(file, rank);
  }
  GameBoard.posKey = GeneratePosKey();
  return UpdateListMaterial();
};
